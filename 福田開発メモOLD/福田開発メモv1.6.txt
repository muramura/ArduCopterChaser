■update_nav_mode
・ここに case NAV_CHASE を追加
・case NAV_CHASE で update_chase() を呼ぶ

■update_chase
・handleMessagesで処置し格納した変数からtargetを作り出す・・・か？
・もしくはhandleMessages内で処置するか
・handleMessagesからdo_chase関数を呼び出し、そこでとりあえず格納

update_chase関数で最初の5mフラグ、chase_target配列にloiterポジションの格納、5m超えたらbeacon_loc


■mavlinkにメッセージを追加する
・GCS_MAVLink/message_definitions/ardupilotmega.xmlをいじって、generate.shをシェルスクリプトとして実行する
・generate.shは改行コードがCR+LFになっていてmacのコマンドプロンプトだとエラーをはくので注意
・mavlinkプログラム（githubより入手）の奥のほうにあるmavgen.pyのフォルダにPATHが通っていないとエラーを吐くので注意
・そのままgenerateするとmavlink_conversions.hが生成されてmavlink_helper.hからincludeされ、それがエラーをはくけど、ひとまずincludeをやめるとコンパイルは通る。他にも色々違う部分ありそう（3.0.1についてくるやつと比べて行数が違う）だけどそのままやってみる


■改造ファイルと場所
chaser.pde（新規）
navigation.pde
　134行目付近　set_nav_modeのスイッチにNAV_CHASERを追加
　171行目付近　nav_modeのスイッチにNAV_CHASERを追加
defines.h
　41行目付近　THROTTLE_AUTO_TAKEOFFを追加　番号は5
　130行目付近　C_TAKEOFFモードとCHASERモードを追加、NUMをふたつ増やす
　190行目付近　#define NAV_CHASER 4とした
　一番下　CHASER関連の#defineはこっちへ移動
commands_logic.pde
　ファイル末尾　do_c_takeoff関数、do_chaser関数を追加
system.pde
　486行目付近　C_TAKEOFFモードとCHASERモードを追加。
ardupilotmega.xml
　348行目付近　CHASER_CMDを追加
ArduCopter.pde
　18xx行目付近　set_throttle_mode内にTHROTTLE_AUTO_TAKEOFFを追加
　19xx行目付近　update_throttle_mode内にTHROTTLE_AUTO_TAKEOFFを追加
　　　　　　　　 自動テイクオフ用にTHROTTLE_AUTOを元にちょい修正。
　

■TODO
・update_chase()　完了
・do_chaser()　完了
・set_mode　完了
・defines　完了
・mavlinkメッセージ追加　完了
・handleMessagesに上記メッセージ追加　完了
・THROTTLE_AUTO_TAKEOFFとAUTOの住み分け、もしくはCHASE 完了

■その他
・CHASERモードに他から入った際、ビーコン位置配列をクリアするのを忘れないように

■131006の気づき
・徒歩レベルでCHASEできた。
　・ビーコンとの通信のタイミングで機体が揺れる。AndroPilotでFollowMeしたときと似ている。
　　ただし、今回は揺れ方が軽微だった。10回平均を取ってるためか？
　・徒歩で10回平均をとっても揺れる。もっと細かくtargetを動かす必要がある。
　　・もっと通信頻度を増やすか、ビーコン位置の予測をして、通信頻度以上に動かすか
　・現時点の性能では40km/hは到底ムリかな
・2回目やったらうまくできず
　・XBeeの問題か？機体のバッテリーもヘタっていたからそれか？
　・1回目のCHASE時も途中でビタっと止まってしまった。その時は機体のXBeeがビーコンと反対方向を向いていた。
　・これは勘だけど、ビーコンのシリアル通信周りが微妙っぽい。
・ビーコンとりあえずできた
　・ArduinoUno＋CRIUS_GPS_I2Cモジュール+ホビキンNEO6M+吉川プログラムで動いた！
　・CRIUS_GPS_I2CモジュールとホビキンNEO6Mをつなぐ際、TX,RXが合っているか要確認（それっぽいケーブルでつなぐと逆になる）



■プロポ無しの自動テイクオフに向けて
見つけたかも。set_throttle_modeの中のIntegerの設定。 @2013.10.4
set_accel_throttle_I_from_pilot_throttle(get_pilot_desired_throttle(g.rc_3.control_in));

get_pilot_desired_throttleは”おそらく”スロットル値をちょこっとスケーリングして返すだけ
set_accel_throttle_I_from_pilot_throttleでI項に-500前後入ってしまう可能性あり
　ただしこの-500だけだといつかなくなるはず。なんで、ここからI項を積算しないなにかがあるのか。
　おそらくAttitude.pde1000行目のあたりだと思うのだけど。
　　Attitude.pde 1000行目
　　// freeze I term if we've breached throttle limits
　    if(motors.reached_limit(AP_MOTOR_THROTTLE_LIMIT)) {
　        i = g.pid_throttle.get_integrator();
　    }else{
　        i = g.pid_throttle.get_i(z_rate_error, .02);
　    }
　    d = g.pid_throttle.get_d(z_rate_error, .02);

g.rc_3.servo_outはおそらくthrottleの出力。
ヘリコプターのタイプによってそれをservoにどう分解するかはset_servos_4()がやってそう
ただ気になるのはthrottle_accelがfalseだとg.rc_3.servo_outが決定されない、ように見えること・・・
そんなことなかった。set_throttle_outがあらゆる場所で呼び出されてたわ。
 


■update_altitudeから追った
update_altitude()はセンサーから値をとってくるだけ。とってくる値はbaro_altとsonar_alt。
↓
AP_InertialNav.cppのAP_InertialNav::correct_with_baroがbaro_altを唯一使っている
↓
correct_with_baroを唯一呼び出すのはAP_InertialNav::check_baro
↓
check_baroを唯一呼び出すのはAP_InertialNav::update
　こいつは、check_gpsも呼び出す。
↓
AP_InertialNav::updateを（唯一か分からないけど）呼び出すのはread_inertia() of inertia.pdeでここでグローバル変数になり
それを呼び出すのはfast_loop

